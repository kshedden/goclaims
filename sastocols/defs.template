package {{ .Ftype }}files

import (
    "strings"
    "strconv"
    "fmt"
    "sync"
    "io"
    "path"
    "os"
    "encoding/binary"

    "github.com/golang/snappy"
    "github.com/kshedden/datareader"
    "github.com/kshedden/goclaims/config"
)

var (
    dtypes = `{{ .Dtypes }}`
)

// rec is a row that will be added to a Bucket.
type rec struct {
{{ range .NameType }}
        {{ .Name }} {{ .GoType }}
{{- end }}
}

// Bucket is a memory-backed container for columnized data.  It
// contains data exactly as it will be written to disk.
type Bucket struct {
        BaseBucket

        code []uint16
{{- range .NameType }}
        {{ .Name }} []{{ .GoType }}
{{- end }}
}

// chunk is a typed container for data pulled directly out of a SAS file.
// There are no type conversions or other modifications from the SAS file.
type chunk struct {
        row int
        col int

{{- range .NameType }}
    {{ .Name }} []{{ .SASType }}
    {{ .Name }}m []bool
{{- end }}
}


// Add appends a rec to the end of the Bucket.
func (bucket *Bucket) Add(r *rec) {

	bucket.Mut.Lock()

{{ range .NameType }}
    bucket.{{ .Name }} = append(bucket.{{ .Name }}, r.{{  .Name }})
{{- end }}

	bucket.Mut.Unlock()

	if uint64(len(bucket.Enrolid)) > conf.BufMaxRecs {
		bucket.Flush()
	}
}

// Flush writes all the data from the Bucket to disk.
func (bucket *Bucket) Flush() {

	logger.Printf("Flushing bucket %d", bucket.BucketNum)

	bucket.Mut.Lock()

{{ range .NameType }}
	bucket.flush{{ .GoType }}("{{ .Name }}", bucket.{{ .Name }})
	bucket.{{ .Name }} = bucket.{{ .Name }}[0:0]
{{- end }}

	bucket.Mut.Unlock()
}


// getcols fills a chunk with data from a SAS file.
func (c *chunk) getcols(data []*datareader.Series, cm map[string]int) error {

	var err error
        var ii int
        var ok bool
{{ range .NameType }}
        ii, ok = cm["{{ .SASName }}"]
        if ok {
	        c.{{ .Name }}, c.{{ .Name }}m, err = data[ii].As{{ .SASTypeU }}Slice()
	        if err != nil {
		        panic(err)
	        }
        {{ if .Must }}
	    } else {
	           msg := fmt.Sprintf("Variable {{ .SASName }} required but not found in SAS file\n")
                   return fmt.Errorf(msg)
            }
	{{ else }}
            }
        {{ end }}
{{ end }}

        return nil
}

func (c *chunk) trynextrec() (*rec, bool) {

	if c.row >= len(c.Enrolid) {
		return nil, false
	}

	r := new(rec)

	i := c.row

	if c.Enrolidm[i] {
	        c.row++
	        return nil, true
        }

{{ range .NameType }}
    {{ if not .Must }}
        if c.{{ .Name }} != nil {
    {{ end }}
    {{ if and (eq .SASType "string") (ne .GoType "string") }}
            // Convert string to number
            if len(c.{{ .Name }}[i]) > 0 {
                x, err := strconv.Atoi(c.{{ .Name }}[i])
		if err == nil {
                    r.{{ .Name }} = {{ .GoType }}(x)
		}
            }
    {{ else if eq .GoType "string" }}
        r.{{ .Name }} = strings.TrimSpace(c.{{ .Name }}[i])
    {{ else }}
        r.{{ .Name }} = {{ .GoType }}(c.{{ .Name }}[i])
    {{ end }}
    {{ if not .Must }}
        }
    {{ end }}
{{- end }}

        c.row++

	return r, true
}


type BaseBucket struct {

	// The number of the bucket, corresponds to the file name in
	// the Buckets directory.
	BucketNum uint32

	// Locks for accessing the bucket's data.
	Mut sync.Mutex

	Conf *config.Config
}

// openfile opens a file for appending data in the bucket's directory.
func (bucket *BaseBucket) openfile(varname string) (io.Closer, io.WriteCloser) {

	bp := config.BucketPath(int(bucket.BucketNum), bucket.Conf)
	fn := path.Join(bp, varname+".bin.sz")
	fid, err := os.OpenFile(fn, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0600)
	if err != nil {
		panic(err)
	}

	gid := snappy.NewBufferedWriter(fid)

	return fid, gid
}

func (bucket *BaseBucket) flushstring(varname string, vec []string) {

	toclose, wtr := bucket.openfile(varname)

	for _, x := range vec {
		_, err := wtr.Write([]byte(x + "\n"))
		if err != nil {
			panic(err)
		}
	}

	err := wtr.Close()
	if err != nil {
 	        panic(err)
        }
	err = toclose.Close()
	if err != nil {
                panic(err)
        }
}


{{- range .Rtypes }}
func (bucket *BaseBucket) flush{{ . }}(varname string, vec []{{ . }}) {

	toclose, wtr := bucket.openfile(varname)

	for _, x := range vec {
		err := binary.Write(wtr, binary.LittleEndian, x)
		if err != nil {
			panic(err)
		}
	}

	err := wtr.Close()
	if err != nil {
                panic(err)
        }
	err = toclose.Close()
	if err != nil {
                panic(err)
        }
}
{{- end }}
